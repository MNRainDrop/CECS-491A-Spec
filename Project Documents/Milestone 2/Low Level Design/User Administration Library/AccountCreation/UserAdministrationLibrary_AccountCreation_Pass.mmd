sequenceDiagram
participant u as User
participant e as Entry Point
participant usm as UserAdministrationManager<br>(Manager Layer)
participant uc as UserService<br>(Services Layer)
participant ss as PepperService<br>(Services Layer)
participant rs as RandomService<br>(Services Layer)
participant ll as LogService<br>(Services Layer)
participant dg as SqlDbUserTarget<br>(Data Gateway)
participant da as SqlServerDAO
participant ds as Data Store

Note Right of e: Assume something in the entry point<br>called the manager to do create a user
Note Right of usm: Assume the user provided values are valid<br>and the user is authorized to create an account

usm->>+uc: CreateValidUserAccount(userName: string, dateOfBirth: string) : IResponse
    Note over usm,uc: UserAdministrationManager calls upon<br>User Service to create the user with the pepper

uc->>uc: UserService creates a new IUserAccountModel object
    Note over uc,uc: string UserName = userName<br>DateTime DateCreated = currentDateTime

uc->>+ss: RetrievePepper(key: string) : uint 
    Note over uc,ss: UserService calls upon<br>PepperService to get a pepper for the UserHash.<br>See PepperService success scenario
ss-->>-uc: PepperService returns the user pepper

uc->>uc: string UserHash = ComputeHash(UserName + UserPepper)
    Note over uc,uc: UserService creates UserHash using the pepper

uc->>rs: GenerateUnsignedInt() : uint
    Note over uc,rs: UserService calls upon<br>RandomService to get a salt for the OTPHash.<br>See RandomService success scenario
rs-->>uc: RandomService returns the salt

uc->>+ss: RetrievePepper(key: string) : uint 
    Note over uc,ss: UserService calls upon<br>PepperService to get a pepper for the OTPHash.<br>See PepperService success scenario
ss-->>-uc: PepperService returns the OTP pepper

uc->>uc: string OTPHash = ComputeHash(UserName + OTPSalt + OTPPepper)
    Note over uc,uc: UserService creates OTPHash using the salt

uc->>uc: Create an IDictionary of<br>claims a user will have

# to data gateway 
uc->>+dg: CreateUserAccountSQL(userAccount: IUserAccountModel, userClaims: IDictionary<claimID: int, claimScope: int>) : IResponse
    Note over uc,dg: UserService calls upon SqlDbUserTarget to generate sql statement and parameters<br>SqlDbUserTarget will create sql statement and parameters for the user first, then the claims next<br>Add the sql statements to a Collection of key value pairs

dg->>+da: ExecuteWriteSQL(sqlCommands: ICollection<KeyValuePair<sql: string, sqlParameters: HashSet<SqlParameter>>>) : IResponse
    Note over dg,da: SqlServerUserTarget calls upon<br>SqlServerDAO to execute the sql

rect rgba(127, 127, 127, 0.2)
loop For every command in sqlCommands

    da->>+ds: SqlCommand.ExecuteNonQuery()
        Note over da,ds: SqlServerDAO calls upon<br>`SqlCommand.ExecuteNonQuery()`<br>to execute the sql command
    alt If storing the User
        ds->>ds: INSERT INTO UserAccount (Username, AccountCreationDate, UserHash)<br> VALUES (UserName, AccountCreationDate, UserHash)
    else
        ds->>ds: INSERT INTO UserClaims (UserID, Claim, ClaimScope)<br> VALUES (SELECT UserID FROM UserAccount WHERE UserName = 'UserName', Claim, ClaimScope)
    end
end
end

ds->>ds: User account is successfull<br>written to the Data Store

ds-->>-da: Database returns the number of rows affected

da-->>-dg: IResponse object returned with<br>`IResponse.ReturnValue` equal to the retrieved value

dg->>dg: SqlDbUserTarget checks that only<br>one row was affected

dg-->>-uc: IResponse object returned with<br>`IResponse.HasError` equal to false

uc-->>ll: CreateLogAsync(logLevel: string, logCategory: string, logContext: string, userHash: string) : IResponse
    Note over uc,ll: UserService calls upon LogService to log<br>successful assignment of claims.<br>See logging success case

uc-->>-usm: IResponse object returned
